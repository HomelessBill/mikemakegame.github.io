---
export interface Props {
  text?: string;
  typingSpeed?: number;
  pauseDuration?: number;
  splitIndex?: number;
  firstColor?: string;
  secondColor?: string;
  loadingDotsSpeed?: number;
  initialDelay?: number;
}

const {
  text = '// Serious technology // Stupid games',
  typingSpeed = 60,
  pauseDuration = 750,
  splitIndex = 23, // Index for both pause and color change
  firstColor = 'text-accent-bright',
  secondColor = 'text-accent',
  loadingDotsSpeed = 250,
  initialDelay = 1000
} = Astro.props;
---

<section class="relative h-[33vh] min-h-[250px] max-h-[350px] md:h-[40vh] md:max-h-none overflow-hidden">
  <!-- Background image container -->
  <div class="absolute inset-0 bg-black">
    <img
      src="/banners/hero-logo.jpg"
      alt="Mike Make Game"
      class="w-auto h-full object-contain mx-auto"
      loading="eager"
    />
    <!-- Gradient overlay for text readability -->
    <div class="absolute inset-0 bg-gradient-to-b from-background/50 via-background/30 to-background/80"></div>
  </div>

  <!-- Text content -->
  <div class="relative h-full flex items-center justify-center">
    <div class="px-4">
      <!-- Fixed min-height to accommodate two lines -->
      <h2 class="text-2xl md:text-3xl lg:text-4xl font-bold font-display drop-shadow-[0_6px_16px_rgba(0,0,0,1)] text-left min-h-[6rem] flex items-start">
        <span id="animated-text"
              data-text={text}
              data-typing-speed={typingSpeed}
              data-pause-duration={pauseDuration}
              data-split-index={splitIndex}
              data-first-color={firstColor}
              data-second-color={secondColor}
              data-dots-speed={loadingDotsSpeed}
              data-initial-delay={initialDelay}
              class="inline-block">Loading</span>
      </h2>
    </div>
  </div>
</section>

<script>
  // Text animation
  const textElement = document.getElementById('animated-text');
  const loadingText = 'Loading';

  // Get configuration from data attributes
  const finalText = textElement.dataset.text;
  const typingSpeed = parseInt(textElement.dataset.typingSpeed);
  const pauseDuration = parseInt(textElement.dataset.pauseDuration);
  const splitIndex = parseInt(textElement.dataset.splitIndex);
  const firstColor = textElement.dataset.firstColor;
  const secondColor = textElement.dataset.secondColor;
  const dotsSpeed = parseInt(textElement.dataset.dotsSpeed);
  const initialDelay = parseInt(textElement.dataset.initialDelay);

  // Convert text with line breaks for display
  function formatText(text) {
    if (!text) return '';
    return text.replace(/\n/g, '<br>');
  }

  // Animate dots
  let dots = 0;
  const dotInterval = setInterval(() => {
    dots++;
    if (dots <= 3) {
      textElement.textContent = loadingText + '.'.repeat(dots);
    }
  }, dotsSpeed);

  // After dots complete, start typewriter effect
  setTimeout(() => {
    clearInterval(dotInterval);

    // Start overwriting from the beginning
    let currentText = loadingText + '...';
    let currentIndex = 0;
    let isPaused = false;
    let hasReachedSplit = false;

    const typeInterval = setInterval(() => {
      if (currentIndex < finalText.length) {
        // Check if we just reached the split point for the first time
        if (currentIndex === splitIndex && !hasReachedSplit && splitIndex >= 0) {
          hasReachedSplit = true;

          if (pauseDuration > 0) {
            isPaused = true;
            setTimeout(() => {
              isPaused = false;
            }, pauseDuration);
            return;
          }
        }

        // If we're still paused, wait
        if (isPaused) {
          return;
        }

        // Build the new text character by character
        currentText = finalText.substring(0, currentIndex + 1) + currentText.substring(currentIndex + 1);

        // Apply colors to the text
        const firstPart = finalText.substring(0, splitIndex);
        const secondPart = finalText.substring(splitIndex);

        // Handle color split
        if (splitIndex >= 0 && splitIndex < finalText.length) {
          // Split is enabled
          if (currentIndex < splitIndex) {
            // Still typing the first part
            const typedFirst = formatText(currentText.substring(0, currentIndex + 1));
            const remaining = formatText(currentText.substring(currentIndex + 1));
            textElement.innerHTML = `<span class="${firstColor}">${typedFirst}</span>${remaining}`;
          } else {
            // Typing the second part
            const firstPart = formatText(finalText.substring(0, splitIndex));
            const typedSecond = formatText(currentText.substring(splitIndex, currentIndex + 1));
            const remaining = formatText(currentText.substring(currentIndex + 1));
            textElement.innerHTML = `<span class="${firstColor}">${firstPart}</span><span class="${secondColor}">${typedSecond}</span>${remaining}`;
          }
        } else {
          // No split - use first color only
          const typed = formatText(currentText.substring(0, currentIndex + 1));
          const remaining = formatText(currentText.substring(currentIndex + 1));
          textElement.innerHTML = `<span class="${firstColor}">${typed}</span>${remaining}`;
        }

        currentIndex++;
      } else {
        // Final state - use the actual text with proper split and formatting
        if (splitIndex >= 0 && splitIndex < finalText.length) {
          const firstPart = formatText(finalText.substring(0, splitIndex));
          const secondPart = formatText(finalText.substring(splitIndex));
          textElement.innerHTML = `<span class="${firstColor}">${firstPart}</span><span class="${secondColor}">${secondPart}</span>`;
        } else {
          // No split or invalid split index
          textElement.innerHTML = `<span class="${firstColor}">${formatText(finalText)}</span>`;
        }

        clearInterval(typeInterval);
      }
    }, typingSpeed);
  }, initialDelay);
</script>
